variables:
  PACKAGE_SCHEME: "MyGuavaPaymentSDK"
  RELEASE_BRANCH: "release"
  GH_TARGET_BRANCH: "master"
  # Set GH_REPO in CI/CD variables as: github.com/<owner>/<repo>.git
  # GH_USERNAME and GH_TOKEN must also be set in CI/CD variables (PAT with repo scope).
  GH_REPO: ""
  GH_USERNAME: ""
  GH_TOKEN: ""
  # Optional: provide VERSION manually (x.y.z). If empty, the job will auto-bump patch.
  VERSION: ""

stages:
  - build
  - test
  - release

default:
  tags:
    - ios
  before_script:
    - set -euo pipefail
    - xcodebuild -version
    - swift --version
    - "export LC_ALL=en_US.UTF-8"
    - "export LANG=en_US.UTF-8"

cache:
  key: "gems-${CI_COMMIT_REF_SLUG}"
  paths:
    - .gem/

workflow:
  rules:
    - if: '$CI_PIPELINE_SOURCE == "merge_request_event"'
      when: always
    - if: '$CI_PIPELINE_SOURCE == "push" && $CI_COMMIT_BRANCH == $CI_DEFAULT_BRANCH'
      when: always
    - if: '$CI_PIPELINE_SOURCE == "push" && $CI_COMMIT_BRANCH && $CI_OPEN_MERGE_REQUESTS == null'
      when: always
    - if: '$CI_PIPELINE_SOURCE == "web"'
      when: always
    - when: never

build_ios:
  stage: build
  script:
    - fastlane build_sdk

test_ios:
  stage: test
  needs:
    - build_ios
  script:
    - fastlane test_sdk

release_prepare:
  stage: release
  needs: []
  when: manual
  allow_failure: false
  rules:
    - if: '$CI_COMMIT_BRANCH == "master"'
      when: manual
    - when: never
  script:
    - |
      set -euo pipefail
      echo "Starting manual release from commit: $CI_COMMIT_SHA"
      # Ensure git is ready
      git fetch --all --prune
      git config user.name "${GITLAB_USER_NAME:-ci}"
      git config user.email "${GITLAB_USER_EMAIL:-ci@example.com}"

      # Validate required GitHub vars
      if [ -z "${GH_REPO:-}" ] || [ -z "${GH_USERNAME:-}" ] || [ -z "${GH_TOKEN:-}" ]; then
        echo "GH_REPO, GH_USERNAME and GH_TOKEN must be set as CI/CD variables." >&2
        exit 1
      fi

      # Prepare Github remote
      git remote remove github 2>/dev/null || true
      git remote add github "https://${GH_USERNAME}:${GH_TOKEN}@${GH_REPO}"

      # Checkout or create the release branch
      if git ls-remote --exit-code --heads origin "${RELEASE_BRANCH}" >/dev/null 2>&1; then
        git checkout -B "${RELEASE_BRANCH}" "origin/${RELEASE_BRANCH}"
      else
        git checkout -b "${RELEASE_BRANCH}"
      fi

      # Cherry-pick current master commit onto release
      PARENTS=$(git rev-list --parents -n 1 "$CI_COMMIT_SHA")
      PCOUNT=$(echo "$PARENTS" | wc -w | tr -d ' ')
      if [ "$PCOUNT" -eq 3 ]; then
        # Merge commit: choose first parent as mainline
        git cherry-pick -m 1 "$CI_COMMIT_SHA"
      else
        git cherry-pick "$CI_COMMIT_SHA"
      fi

      # Compute tag: use provided VERSION or auto-bump patch from last tag
      if [ -n "${VERSION:-}" ]; then
        NEW_TAG="$VERSION"
      else
        LAST_TAG=$(git tag --list --sort=-v:refname | head -n1)
        if [ -z "$LAST_TAG" ]; then LAST_TAG="0.0.0"; fi
        IFS='.' read -r MA MI PA <<EOF
        $LAST_TAG
        EOF
        : "${MA:=0}"; : "${MI:=0}"; : "${PA:=0}"
        PA=$((PA+1))
        NEW_TAG="${MA}.${MI}.${PA}"
      fi

      if git rev-parse -q --verify "refs/tags/${NEW_TAG}" >/dev/null; then
        echo "Tag ${NEW_TAG} already exists. Aborting." >&2
        exit 1
      fi

      echo "Releasing ${NEW_TAG} from $(git rev-parse --short HEAD) on branch ${RELEASE_BRANCH}"

      # Push release branch and tag to GitLab
      git tag -a "${NEW_TAG}" -m "Release ${NEW_TAG}"
      git push origin "${RELEASE_BRANCH}"
      git push origin "${NEW_TAG}"

      # Push release branch into GitHub master and the tag
      git push github "${RELEASE_BRANCH}:refs/heads/${GH_TARGET_BRANCH}"
      git push github "${NEW_TAG}"

      echo "Release ${NEW_TAG} pushed to GitLab (${RELEASE_BRANCH} + tag) and GitHub (${GH_TARGET_BRANCH} + tag)."
  tags:
    - ios
  artifacts:
    when: always
    reports:
      dotenv: []
    expire_in: 1 day
